# *** Common support functions for interactive shells (shared by bash/zsh) ***

# FUNCTIONS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Convert to all lowercase characters.
lowercase() {
    echo "$1" | tr 'A-Z' 'a-z'
}  

# Convert to all uppercase characters.
uppercase() {
    echo "$1" | tr 'a-z' 'A-Z'
}  

# Remove spaces.
nospaces() {
    echo "${1// /}"
}  

# Convert spaces to dashes.
dashws() {
    echo ""${1// /-}""
}  

# Convert spaces to underscores.
underscorews() {
    "echo ${1// /_}"
}  

# Remove dashes.
nodashes() {
    echo "${1//-/}"
}  

# Remove parens.
noparens() {
    echo "${1//[\(\)]/}"
}  

# Remove non-alphanumeric characters.
alphanum() {
    echo "${1//[^ _a-zA-Z0-9]/}"
}  

# Remove non-alphanumeric characters. (Keeping dashes)
alphanumdash() {
    echo "${1//[^ -_a-zA-Z0-9]/}"
}  

# Convert to safe user ID string.
userID() {
    : `nospaces "$1"`
    : `noparens "$_"`
    : `alphanum "$_"`
    : `lowercase "$_"`
    echo "$_"
}

# Convert to safe project ID string.
projID() {
    : `nospaces "$1"`
    : `noparens "$_"`
    : `alphanumdash "$_"`
    : `lowercase "$_"`
    echo "$_"
}

# Convert to safe package ID string.
pkgID() {
    : `nospaces "$1"`
    : `noparens "$_"`
    : `projID "$_"`
    : `nodashes "$_"`
    echo "$_"
}

isBinary() {
  test `head -qc 8192 "$1" | grep -o '[^[:print:]]' | wc -c` -gt 16
}

# Shell-escape special characters
esc() { echo $(printf '%q' "$1"); }

# Unescape a shell-escaped string
unesc() { bash -c echo\ "$e"; }

# Escape single-quotes to make a single-quotable string
sq() { printf '%s' "${1//'/'\\''}"; }

# Escape special chars and newlines to make a double-quotable string
dq() { printf '%s' "$1" | sed -e 's/[$!&`"\]/\\&/g'; }

# Escape chars and newlines to make a double-quotable string
dquo() {
  esc_chars='s/[$`"\]/\\&/g'
  echo "$1" | sed -e "$esc_chars" | (
    while read line; do echo -n "$(echo "$line" | sed -e "$esc_chars")\n"; done
  ) | sed -e 's/\\n$//'
}

# Get relative path from source directory (1st arg) to target directory (2nd arg)
# Use absolute path if supplying a directory that does not exist
rel_dir() {(
  shopt -s extglob
  _rel_down() {
	[[ "$1" = '/' && ! "$2" = '/' ]] && local pre='./' || local pre='.'
	[[ "$2" =~ ^"$1" ]] && echo "$pre${2#"$1"}"
  }
  _rel_up() {
	while [[ ! "$(_rel_down "$1" "$2")" ]]; do
	  set -- "$(dirname "$1")" "$2" 
	  local back="../$back" rest="${2#"$1"}"
	done
	echo "$back${rest#/}"
  }
  local rel a b
  [[ -d "$1" ]] && a="$(readlink -f "$1")" || a="${1/%%+(/)}"
  [[ -d "$2" ]] && b="$(readlink -f "$2")" || b="${2/%%+(/)}"
  rel="$(_rel_down "$a" "$b")"; 
  [[ ! $rel ]] && rel="$(_rel_up "$a" "$b")"
  echo "$rel"
)}
