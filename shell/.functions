# *** Common support functions for interactive shells (shared by bash/zsh) ***

# FUNCTIONS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Convert to all lowercase characters.
lowercase() {
    echo "$1" | tr 'A-Z' 'a-z'
}  

# Convert to all uppercase characters.
uppercase() {
    echo "$1" | tr 'a-z' 'A-Z'
}  

# Remove spaces.
nospaces() {
    echo "${1// /}"
}  

# Convert spaces to dashes.
dashws() {
    echo ""${1// /-}""
}  

# Convert spaces to underscores.
underscorews() {
    "echo ${1// /_}"
}  

# Remove dashes.
nodashes() {
    echo "${1//-/}"
}  

# Remove parens.
noparens() {
    echo "${1//[\(\)]/}"
}  

# Remove non-alphanumeric characters.
alphanum() {
    echo "${1//[^ _a-zA-Z0-9]/}"
}  

# Remove non-alphanumeric characters. (Keeping dashes)
alphanumdash() {
    echo "${1//[^ -_a-zA-Z0-9]/}"
}  

# Convert to safe user ID string.
userID() {
    : `nospaces "$1"`
    : `noparens "$_"`
    : `alphanum "$_"`
    : `lowercase "$_"`
    echo "$_"
}

# Convert to safe project ID string.
projID() {
    : `nospaces "$1"`
    : `noparens "$_"`
    : `alphanumdash "$_"`
    : `lowercase "$_"`
    echo "$_"
}

# Convert to safe package ID string.
pkgID() {
    : `nospaces "$1"`
    : `noparens "$_"`
    : `projID "$_"`
    : `nodashes "$_"`
    echo "$_"
}

isBinary() {
  test `head -qc 8192 "$1" | grep -o '[^[:print:]]' | wc -c` -gt 16
}

# Shell-escape special characters
esc() { echo $(printf '%q' "$1"); }

# Unescape a shell-escaped string
unesc() { bash -c echo\ "$e"; }

# Escape single-quotes to make a single-quotable string
sq() { printf '%s' "${1//'/'\\''}"; }

# Escape special chars and newlines to make a double-quotable string
dq() { printf '%s' "$1" | sed -e 's/[$!&`"\]/\\&/g'; }

# Escape chars and newlines to make a double-quotable string
dquo() {
  esc_chars='s/[$`"\]/\\&/g'
  echo "$1" | sed -e "$esc_chars" | (
    while read line; do echo -n "$(echo "$line" | sed -e "$esc_chars")\n"; done
  ) | sed -e 's/\\n$//'
}

# relpath() {
#   local common path up
#   common=${1%/} path=${2%/}/
#   while test "${path#"$common"/}" = "$path"; do
#       common=${common%/*} up=../$up
#   done
#   path=$up${path#"$common"/}; path=${path%/}; printf %s "${path:-.}"
# }
#
# rel() {
#   local common="$1" path="$2"/ up
#   while [[ "${path#"$common"/}" = "$path" ]]; do
#       echo "-- ${path#"$common"/}" "$path"
#       common=${common%/*} up=../$up
#       echo "== ${path#"$common"/}" "$path"
#   done
#   path=$up${path#"$common"/}; path=${path%/}; printf %s "${path:-.}"
# }
#
# # Return relative path from first arg to 2nd arg. Args must be absolute paths without trailing '/'
# # rel() {
# #   local relpath=''
# #   while [[ "${2#"$1"/}" = "$2" ]]; do set -- "${1%/*}" "$2"; relpath+="../"; done
# #   relpath+="${2#"$1"/}${2%/}" && printf %s "${relpath:-.}"
# # }
#
# setrel() {
#   if [[ "$2" =~ ^"$1" ]]; then
#     printf '%s' "${2#$1}"
#   elif [[ "$1" =~ ^"$2" ]]; then
#     printf '.'
#     [[ ! "$1" = "$2" ]] && printf '.'
#     printf '%s' "$(setrel "${1%/*}" "$2")"
#   # else
#   #   printf "$1"
#   fi
#   # echo "$1" "$2"
#   # while [[ "$1" =~ ^"$2" ]]; do
#   #   echo "::: $1 $2"
#   #   set -- "${1%/*}" "$2"
#   # done
#   # echo "$1" "$2"
# }
#
# rel_dir() {
#   if [[ "$1" = "$2" ]]; then
#     printf '.'
#   elif [[ "$2" =~ ^"$1" ]]; then
#     printf '%s' "${2#"$1"/}"
#   elif [[ "$1" =~ ^"$2" ]]; then
#     printf "/${1#"$2"/}" | sed -e 's#/[^/]*#../#g'
#   fi
# }

# / /a/b/c
# /a /a/b/c
# /a/b /a/b/c
# /a/b/c /a/b/c
# /a/b/d /a/b/c
# /a/b/c /a/b
# /a/b/c /a
# /a/b/c /

# re() {
#   [[ "$1" = "$2" ]] && echo "."
# }
rel() {(
  shopt -s extglob
  _rel_down() {
	[[ "$1" = '/' && ! "$2" = '/' ]] && local pre='./' || local pre='.'
	[[ "$2" =~ ^"$1" ]] && echo "$pre${2#"$1"}"
  }
  _rel_up() {
	while [[ ! "$(_rel_down "$1" "$2")" ]]; do
	  set -- "$(dirname "$1")" "$2" 
	  local back="../$back" rest="${2#"$1"}"
	done
	echo "$back${rest#/}"
  }
  local rel a b
  [[ -d "$1" ]] && a="$(readlink -f "$1")" || a="${1/%%+(/)}"
  [[ -d "$2" ]] && b="$(readlink -f "$2")" || b="${2/%%+(/)}"
  rel="$(_rel_down "$a" "$b")"; 
  [[ ! $rel ]] && rel="$(_rel_up "$a" "$b")"
  echo "$rel"
)}
